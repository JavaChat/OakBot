<!--
All text in this file is from the book Effective Java, Third Edition, by Joshua Bloch.
The titles and summaries may contain the following two Markdown metacharacters: * `
-->
<items>
	<item number="1" page="5">
		<title>Consider static factory methods instead of constructors</title>
		<summary>Static factory methods and public constructors both have their uses, and it pays to understand their relative merits. Often static factories are preferable, so avoid the reflex to provide public constructors without first considering static factories.</summary>
	</item>
	<item number="2" page="10">
		<title>Consider a builder when faced with many constructor parameters</title>
		<summary>*summary missing*</summary>
	</item>
	<item number="3" page="17">
		<title>Enforce the singleton property with a private constructor or an enum type</title>
		<summary>This approach is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. This approach may feel a bit unnatural, but a single-element enum type is often the best way to implement a singleton.</summary>
	</item>
	<item number="4" page="19">
		<title>Enforce noninstantiability with a private constructor</title>
		<summary>It guarantees the class will never be instantiated under any circumstances. This idiom is mildly counter-intuitive because the constructor is provided expressly so that it cannot be invoked. It is therefore wise to include a comment.</summary>
	</item>
	<item number="5" page="20">
		<title>Prefer dependency injection to hardwiring resources</title>
		<summary>Do not use a singleton or static utility class to implement a class that depends on one or more underlying resource is this behavior effects that of the class, and do not have the class create these resources directly. Instead, pass the resources, or factories to create them, into the constructor (or static factory or builder). This practice, known as dependency injection, will greatly enhance the flexibility, reusability, and testability of a class.  </summary>
	</item>
	<item number="6" page="22">
		<title>Avoid creating unnecessary objects</title>
		<summary>It is often appropriate to reuse a single object instead of creating a new functionally equivalent object each time it is needed. Reuse can be both faster and more stylish. An object can always be reused if it is immutable (Item 17).</summary>
	</item>
	<item number="7" page="26">
		<title>Eliminate obsolete object references</title>
		<summary>Memory leaks in garbage collected languages (more properly known as (unintentional object retentions*) are insidious. If an object reference is unintentionally retained, not only is that object excluded from garbage collection, but so too are any objects referenced by that object, and so on. Even if only a few object references are unintentionally retained, many, many objects may be prevented from being garbage collected, with potentially large effects on performance.</summary>
	</item>
	<item number="8" page="29">
		<title>Avoid finalizers and cleaners</title>
		<summary>Don't use cleaners, or in releases prior to Java 9, finalizers, except as a safety net or to terminate noncritical native resources. Even then, beware of the indeterminacy and performance consequences.</summary>
	</item>
	<item number="9" page="34">
		<title>Prefer `try`-with-resources to `try-finally`</title>
		<summary>Always use `try`-with-resources in preference to `try-finally` when working with resources that must be closed. The resulting code is shorter and clearer, and the exceptions that it generates are more useful. The `try`-with-resources statement makes it easy to write correct code using resources that must be closed, which was practically impossible using `try-finally`.</summary>
	</item>
	<item number="10" page="37">
		<title>Obey the general contract when overriding `equals`</title>
		<summary>Don't override the `equals` method unless you have to: in many cases, the implementation inherited from `Object` does exactly what you want. If you do not override `equals`, make sure to compare all of the classes significant fields and to compare them in a manner that preserves all five provisions of the equals contract.</summary>
	</item>
	<item number="11" page="50">
		<title>Always override hashCode when you override `equals`</title>
		<summary>You must override `hashCode` every time you override `equals`, or your program will not run correctly. Your `hashCode` method must obey the general contract specified in `Object` and must do a reasonable job assigning unequal `hashCode` to unequal instances. This is easy to achieve, if slightly tedious, using the recipe on page 51. As mentioned in Item 10, the AutoValue framework provides a fine alternative to writing `equals` and `hashCode` methods manually, and IDEs also provide some of this functionality.</summary>
	</item>
	<item number="12" page="55">
		<title>Always override `toString`</title>
		<summary>Override `Object`'s `toString` implementation in every instantiable class you write, unless a superclass has already done so. It makes classes much more pleasant to use and aids in debugging. The `toString` method should return a concise, useful description of the object, in an aesthetically pleasing format.</summary>
	</item>
	<item number="13" page="58">
		<title>Override `clone` judiciously</title>
		<summary>Given all the problems associated with `Cloneable`, new interfaces should not extend it, and new extendible classes should not implement it. While it's less harmful for final classes to implement `Cloneable`, they should be viewed as a performance optimization, reserved for the rare cases where it is justified (Item 67). As a rule, copy functionality is best provided by constructors or factories. A notable exception to this rule is arrays, which are best copied with the clone method.</summary>
	</item>
	<item number="14" page="66">
		<title>Consider implementing `Comparable`</title>
		<summary>Whenever you implement a value class that has a sensible ordering, you should have the class implement the `Comparable` interface so that its instances can be easily sorted, searched, and used in comparison-based collections. When comparing field values in the implementations of the `compareTo` methods, avoid the use of the &lt; and &gt; operators. Instead, use the static compare methods in the boxed primitive classes or the comparator construction methods in the `Comparator` interface.</summary>
	</item>
	<item number="15" page="73">
		<title>Minimize the accessibility of classes and members</title>
		<summary>You should reduce accessibility of program elements as much as possible (within reason). After carefully designing a minimal public API, you should prevent any stray classes, interfaces, or members from becoming part of the API. With the exception of public static final fields, which service constants, public classes should have no public fields. Ensure that objects referenced by public static final fields are immutable.</summary>
	</item>
	<item number="16" page="78">
		<title>In public classes, use accessor methods, not public fields</title>
		<summary>Public classes should never expose mutable fields. It is less harmful, though still questionable, for public classes to expose immutable fields. It is, however, sometimes desirable for a package-private or private nested classes to expose fields, whether mutable or immutable.</summary>
	</item>
	<item number="17" page="80">
		<title>Minimize mutability</title>
		<summary>Immutable classes are easier to design, implement, and use than mutable classes. They are less prone to error and are more secure.</summary>
	</item>
	<item number="18" page="87">
		<title>Favor composition over inheritance</title>
		<summary>Inheritance is powerful, but it is problematic because it violates in encapsulation. It is appropriate only when a genuine subtype relationship exists between the subclass and the superclass. Even then, inheritance made lead to fragility if the subclass is in a different package from the superclass and the superclass is not designed for inheritance. To avoid this fragility, use composition and forwarding instead of inheritance, especially if an appropriate interface to implement a wrapper class exists. Not only are wrapper classes more robust than subclasses, they are also more powerful.</summary>
	</item>
	<item number="19" page="93">
		<title>Design and document for inheritance or else prohibit it</title>
		<summary>Designing a class for inheritance is hard work. You must document all of its self-use patterns, and once you've documented them, you must commit them for the life of the class. If you fail to do this, subclasses may become dependent on implementation details of the superclass and may break if the implementation of the superclass changes. To allow others to write *efficient* subclasses, you may also have to export one or more protected methods. Unless you know there is a real need for subclasses you are probably better off prohibiting inheritance by declaring your class final or ensuring that there are no inaccessible constructors.</summary>
	</item>
	<item number="20" page="99">
		<title>Prefer interfaces to abstract classes</title>
		<summary>An interface is generally the best way to define a type that permits multiple implementations. If you export a nontrivial interface, you should strongly consider providing a skeletal implementation to go with it. To the extent possible, you should provide the skeletal implementation the default methods on the interface so that all implementors of the interface can make use of it. That said, restrictions on interfaces typically mandate that a skeletal implementation take the form of an abstract class.</summary>
	</item>
	<item number="21" page="104">
		<title>Design interfaces for posterity</title>
		<summary>While it may be possible to correct some interface flaws after an interface is released, you cannot count on it.</summary>
	</item>
	<item number="22" page="107">
		<title>Use interfaces only to define types</title>
		<summary>Interfaces should be used only to define types. They should not be used merely to export constants.</summary>
	</item>
	<item number="23" page="109">
		<title>Prefer class hierarchies to tagged classes</title>
		<summary>Tagged classes are seldom appropriate. If you're tempted to write a class with an explicit tag field, think about whether the tag could be eliminated and the class replaced by a hierarchy. When you encounter an existing class with a tagg field, consider refactoring it into a hierarchy.</summary>
	</item>
	<item number="24" page="112">
		<title>Favor static member classes over nonstatic</title>
		<summary>There are four different kinds of nested classes, and each has its place. If a nested class needs to be visible outside of a single method or is too long to fit comfortably inside a method, use a member class. If each instance of a member class needs a reference to its enclosing instance, make it nonstatic; otherwise, make it static. Assuming the class belongs inside a method, if you need to create instances from only one location and there is a preexisting type that characterizes the class, make it an anonymous class; otherwise, make it a local class.</summary>
	</item> 
	<item number="25" page="115">
		<title>Limit source files to a single top-level class</title>
		<summary>Never put multiple top level classes or interfaces in a single source file. Following this rule guarantees that you can't have multiple definitions for a single class at compile time. This in turn guarantees that the class files generated by compilation, and the behavior of the resulting program, are independent of the order in which the source files are passed to the compiler.</summary>
	</item>
	<item number="26" page="117">
		<title>Don't use raw types</title>
		<summary>Using raw types types can lead to exceptions at runtime, so don't use them. They are provided only for compatibility and interoperability with legacy code that predates the introduction of generics.</summary>
	</item>
	<item number="27" page="123">
		<title>Eliminate unchecked warnings</title>
		<summary>Unchecked warnings are important. Don't ignore them. Every unchecked warning represents the potential for a `ClassCastException` at runtime. Do your best to eliminate these warnings. If you can't eliminate an unchecked warning and you can prove that the code that provoked it is typesafe, suppress the warning with a `@SuppressWarnings("unchecked")` annotation in the narrowest possible scope. Record the rationale for your decision to suppress the warning in a comment.</summary>
	</item>
	<item number="28" page="126">
		<title>Prefer lists to arrays</title>
		<summary>Arrays and generics have very different type rules. Arrays are covariant and reified; generics are invariant erased. As a consequence, arrays provide runtime type safety but not compile-time type safety, and vice versa for generics. As a rule, arrays and generics don't mix well. If you find yourself mixing them and getting compile time errors or warnings, your first impulse should be to replace the arrays with lists.</summary>
	</item>
	<item number="29" page="130">
		<title>Favor generic types</title>
		<summary>Generic types are safer and easier to use than types that require casts in client code. When you design new types, make sure that they can be used without such casts. This will often mean making the types generic. If you have any existing types that should be generic but aren't, generify them. This will make life easier for new users of these types without breaking existing clients (Item 26).</summary>
	</item> 
	<item number="30" page="135">
		<title>Favor generic methods</title>
		<summary>Generic methods, like generic types, are safer and easier to use than methods requiring their clients to put explicit casts on input parameters and return values. Like types, you should make sure that your methods can be used with without casts, which often means making them generic. And like types, you should generify existing methods whose use requires casts. This makes life easier for new users without breaking existing clients (Item 26).</summary>
	</item>
	<item number="31" page="139">
		<title>Use bounded wildcards to increase API flexibility</title>
		<summary>Using wildcard types in your APIs, well tricky, makes the APIs far more flexible. If you write a library that will be widely used, the proper use of wildcard types should be considered mandatory. Remember the basic rule: producer-`extends`, consumer-`super` (PECS). Also remember that all comparables and comparators are consumers.</summary>
	</item>
	<item number="32" page="146">
		<title>Combine generics and varargs judiciously</title>
		<summary>Varargs and generics do not interact well because the varargs facility is a leaky abstractions built atop arrays, and arrays have different type rules from generics. Though generic varargs parameters are not typesafe, they are legal. If you choose to write a method with a generic (or parameterized) varargs parameter, first ensure that the method is typesafe, and then annotate it with `@SafeVarargs` so it is not unpleasant to use.</summary>
	</item> 
	<item number="33" page="151">
		<title>Consider typesafe heterogeneous containers</title>
		<summary>The normal use of generics, exemplified by the collections APIs, restricts you to a fixed number of type parameters per container. You can get around this restriction by placing the type parameter on the key rather than the container. You can use `Class` objects as keys for such typesafe heterogeneous containers. A `Class` object used in this fashion is called a type token. You can also use a custom key type. For example, you could have a `DatabaseRow` type representing a database row (the container), and a generic type `Column&lt;T&gt;` at its key.</summary>
	</item>
	<item number="34" page="157">
		<title>Use enums instead of `int` constants</title>
		<summary>The advantages of enum types of over `int` constants are compelling.  Enums are more readable, safer, and more powerful. Many enums require no explicit constructors or members, but others benefit from associating data with each constant and providing methods whose behavior is affected by this data. Fewer enums benefit from associating multiple behaviors with a single method. In this relatively rare case, prefer constant-specific methods to enums that switch on their own values. Consider the strategy enum pattern if some, but not all, constants share common behaviors.</summary>
	</item>
	<item number="35" page="168">
		<title>Use instance fields instead of ordinals</title>
		<summary>The `Enum` specification has this to say about ordinal: "Most programmers will have no use for this method. It is designed for use by general-purpose enum-based data structures such as `EnumSet` and `EnumMap`." Unless you are writing code with this character, you are best off avoiding the ordinal method entirely.</summary>
	</item>
	<item number="36" page="169">
		<title>Use `EnumSet` instead of bit fields</title>
		<summary>Just because an enumerated type will be used in set, there is no reason to represent it with that field. The `EnumSet` class combines the conciseness and performance of that field with all the many advantages of enum types described in Item 34. The one real disadvantage of `EnumSet` is that it is not, as of Java 9, possible to create an immutable in `EnumSet`, but this will likely be remedied in an upcoming release. In the meantime, you can wrap an `EnumSet` with `Collections.unmodifiableSet`, but conciseness and performance will suffer.</summary>
	</item>
	<item number="37" page="171">
		<title>Use `EnumMap` instead of ordinal indexing</title>
		<summary>It is rarely appropriate to use ordinals to index into arrays: use `EnumMap` instead. If the relationship you are representing is multidimensional, use `EnumMap&lt;..., EnumMapM&lt;...&gt;&gt;`. This is a special case of the general principle that application programmers should rarely, if ever, use `Enum.ordinal` (Item 35).</summary>
	</item>
	<item number="38" page="176">
		<title>Emulate extensible enums with interfaces</title>
		<summary>While you cannot write an extensible enum type, you can emulate it by writing interface to accompany a basic enum type that represents the interface. This allows clients to write their own enums (or other types) that implement the interface. Instances of these types can then be used wherever instances of the basic enum type can be used, assuming APIs are written in terms of the interface.</summary>
	</item>
	<item number="39" page="180">
		<title>Prefer annotations to naming patterns</title>
		<summary>With the exception of toolsmiths, most programmers will have no need to define annotation types. But all programmers should use the predefined annotation types that Java provides.</summary>
	</item>
	<item number="40" page="188">
		<title>Consistently use the `Override` annotation</title>
		<summary>The compiler can protect you from a great many errors if you use the override annotation on every method declaration that you believe to override a supertype declaration, with one exception. In concrete classes, you need not annotate methods that you believe to override abstract method of declarations (though it is not harmful to do so).</summary>
	</item> 
	<item number="41" page="191">
		<title>Use marker interfaces to define types</title>
		<summary>Marker interfaces and marker annotations both have their uses. If you want to define a type that does not have any new methods associated with it, a marker interface is the way to go. If you want to mark program elements other than classes and interfaces or to fit the marker into a framework that already makes heavy use of annotation types, then a marker annotation is the correct choice. If you find yourself writing a marker annotation type whose target is `Element.TYPE`, take the time to figure out whether it really should be an annotation type or whether a marker interface would be more appropriate.</summary>
	</item>
	<item number="42" page="193">
		<title>Prefer lambdas to anonymous classes</title>
		<summary>As of Java 8, lambdas are by far the best way to represent small function objects. Don't use anonymous classes for function objects unless you have to create instances of types that aren't functional interfaces. Also, remember that lambdas make it so easy to represent small function objects that it opens the door to functional programming techniques that were not previously practical in Java.</summary>
	</item>
	<item number="43" page="197">
		<title>Prefer method references to lambdas</title>
		<summary>Message references often provide a more succinct alternative to lambdas. Where method references are shorter and clearer, use them; where they aren't, stick with lambdas.</summary>
	</item>
	<item number="44" page="199">
		<title>Favor the use of standard functional interfaces</title>
		<summary>Now that's Java has lambdas, it is imperative that you design your APIs with lambdas in mind. Accept functional interface types on input and return them on output. It is generally best to use the standard interfaces provide provided in `java.util.function.Function`, but keep your eyes open for the relatively rare cases where you would be better off writing your own functional interface.</summary>
	</item>
	<item number="45" page="203">
		<title>Use streams judiciously</title>
		<summary>Some tasks are best accomplished with streams, and others with iteration. Many tasks are best accomplished by combining the two approaches. There are no hard and fast rules for choosing which approach to use for a task, but there are some useful heuristics. In many cases, it will be clear which approach to use; in some cases, it won't. If you are not sure whether a task is better served by streams or iteration, try both and see which works better.</summary>
	</item>
	<item number="46" page="210">
		<title>Prefer side-effect-free functions in streams</title>
		<summary>The essence of programming stream pipelines is side-affect-free function objects. This applies to all of the many function objects past to streams and related objects. The terminal operation `forEach` should only be used to report the result of a computation performed by a stream, not to perform the computation. In order to use streams properly, you have to know about collectors. The most important collector factories are `toList`, `toSet`, `toMap`, `groupingBy`, and `joining`.</summary>
	</item>
	<item number="47" page="216">
		<title>Prefer Collection to Stream as a return type</title>
		<summary>When writing a method that returns a sequence of elements, remember that some of your users may want to process them as a stream while others may want to iterate over them. Try to accommodate both groups. If it's feasible to return a collection, do so. If you already have the elements in a collection or the number of elements in the sequence is small enough to justify creating a new one, return a standard collection such as `ArrayList`. Otherwise, consider implementing a custom collection as we did for the power set. If it isn't feasible to return a collection, return a `Stream` or `Iterable`, whichever seems more natural. If, in a future Java release, the stream interface declaration is modified to extend `Iterable`, then you should feel free to return streams because they will allow for both stream processing and iteration.</summary>
	</item>
	<item number="48" page="222">
		<title>Use caution when making streams parallel</title>
		<summary>Do not even attempt to parallelize a stream pipeline unless you have a good reason to believe that it will preserve the correctness of the computation and increase its speed. The cost of inappropriately parallelizing a stream can be a program failure or performance disaster. If you believe that parallelism may be justified, ensure that your code remains correct when run in parallel, and do careful performance measurements under realistic conditions. If your code remains correct and these experiments bear out your suspicion of increased performance, then and only then parallelize the stream in production code.</summary>
	</item>
	<item number="49" page="227">
		<title>Check parameters for validity</title>
		<summary>Each time you write a method or constructor, you should think about what restrictions exist on its parameters. You should document these restrictions and enforce them with explicit checks at the beginning of the method body. It is important to get into the habit of doing this. The modest work that it entails will be paid back with interest the first time a validity check fails.</summary>
	</item>
	<item number="50" page="231">
		<title>Make defensive copies when needed</title>
		<summary>If a class has mutable components that it gets from or returns to its clients, the class must defensively copy these components. If the cost of the copy would be prohibitive and the class trust its clients not to modify the components inappropriately, then the defensive copy may be replaced by documentacion outlining the clients responsibility not to modify the affected components.</summary>
	</item>
	<item number="51" page="236">
		<title>Design method signatures carefully</title>
		<summary>This item is a grab bag of API design hints that don't quite deserve items of their own.</summary>
	</item>
	<item number="52" page="238">
		<title>Use overloading judiciously</title>
		<summary>Just because you can overload methods doesn't mean you should. It is generally best to refrain from overloading methods with multiple signatures that have the same number of parameters. In some cases, especially where constructors are involved, it may be impossible to follow this advice. In these cases, you should at least avoid situations where the same set of parameters can be passed to different overloadings by the addition of casts. If this cannot be avoided, for example, because you are retrofitting an existing class to implement a new interface, you should ensure that all overloadings behave identically when passed the same parameters. If you fail to do this, programmers will be hard pressed to make effective use of the overloaded method or constructor, and they won't understand why it doesn't work.</summary>
	</item>
	<item number="53" page="245">
		<title>Use varargs judiciously</title>
		<summary>Varargs are invaluable when you need to define methods with a variable number of arguments. Precede the varargs parameter with any required parameters, and be aware of the performance consequences of using varargs.</summary>
	</item> 
	<item number="54" page="247">
		<title>Return empty collections or arrays, not nulls</title>
		<summary>Never return `null` in place of an empty array or collection. It makes your API more difficult to use and more prone to error, and it has no performance advantages.</summary>
	</item>
	<item number="55" page="249">
		<title>Return optionals judiciously</title>
		<summary>If you find yourself writing a method that can't always return a value and you believe it is important that users of the method consider this possibility every time they call it, then you should probably return an optional. You should, however, be aware that there are real performance consequences associated with returning optionals; for performance-critical methods, it may be better to return a `null` or throw an exception. Finally, you should rarely use an optional in any other capacity than as a return value.</summary>
	</item>
	<item number="56" page="254">
		<title>Write doc comments for all exposed API elements</title>
		<summary>Documentation comments are the best, most effective way to document your API. Their use should be considered mandatory for all exported API elements. Adopt a consistent style that adheres to standard conventions. Remember that arbitrary HTML is permissible in documentation comments and that HTML metacharacters must be escaped. </summary>
	</item>
	<item number="57" page="261">
		<title>Minimize the scope of local variables</title>
		<summary>By minimizing the scope of local variables, you increase the readability and maintainability of your code and reduce the likelihood of error.</summary>
	</item>
	<item number="58" page="264">
		<title>Prefer for-each loops to traditional `for` loops</title>
		<summary>The for-each loop provides compelling advantages over the traditional `for` loop in clarity, flexibility, and bug prevention, with no performance penalty. Use for-each loops in preference to `for` loops wherever you can.</summary>
	</item>
	<item number="59" page="267">
		<title>Know and use the libraries</title>
		<summary>Don't reinvent the wheel. If you need to do something that seems like it should be reasonably common, there may already be a facility in the libraries that does what you want. If there is, use it; if you don't know, check. Generally speaking, library code is likely to be better than code that you to write yourself and is likely to improve over time. This is no reflection on your abilities as a programmer. Economies of scale dictate that library code receives far more attention than most developers could afford to devote to the same functionality.</summary>
	</item>
	<item number="60" page="270">
		<title>Avoid `float` and `double` if exact answers are required</title>
		<summary>Don't use `float` or `double` for any calculations that require an exact answer. If performance is of the essence, you don't mind keeping track of the decimal point yourself, and the quantities aren't too big, use `int` or `long`. If the quantities don't exceed nine decimal digits, you can use `int`; if they don't exceed eighteen digits, you can use `long`. If the quantities might exceed eighteen digits, use `BigDecimal`.</summary>
	</item>
	<item number="61" page="273">
		<title>Prefer primitive types to boxed primitives</title>
		<summary>Use primitives in preference to boxed primitives whenever you have the choice. Primitive types are simpler and safer. If you must use boxed primitives, be careful! Autoboxing reduces the verbosity, but not the danger, of using a boxed primitives. When your program compares two boxed primitives with the `==` operator, it does an identity comparison, which is almost certainly *not* what you want. When your program does mixed-type computations involving boxed and unboxed primatives, it does unboxing, and when your program does unboxing, it can throw a `NullPointerException`. Finally, when your program boxes primitive values, it can result in costly and unnecessary object creations.</summary>
	</item>
	<item number="62" page="276">
		<title>Avoid strings where other types are more appropriate</title>
		<summary>Avoid the natural tendency to represent objects as strings when better datatypes exist or can be written. Used inappropriately, strings are more cumbersome, less flexible, slower, and more error prone than other types. Types for which strings are commonly misused include primitive types, enums, and aggregate types.</summary>
	</item>
	<item number="63" page="279">
		<title>Beware the performance of string concatenation</title>
		<summary>Don't use the string concatenation operator to combine more than a few strings unless performance is irrelevant. Use `StringBuilder`'s `append` method instead. Alternatively, use a character array, or process the strings one at a time instead of combining them.</summary>
	</item>
	<item number="64" page="280">
		<title>Refer to objects by their interfaces</title>
		<summary>In practice, it should be apparent whether a given object has an appropriate interface. If it does, your program will be more flexible and stylish if you use the interface to refer to the object. If there is no appropriate interface, just use the least specific class in the class hierarchy that provides the required functionality.</summary>
	</item>
	<item number="65" page="282">
		<title>Prefer interfaces to reflection</title>
		<summary>Reflection is a powerful facility that is required for certain sophisticated system programming tasks, but it has many disadvantages. If you are writing a program that has to work with classes unknown at compile time, you should, if at all possible, use reflection only to instantiate objects, and access the objects using some interface or superclass that is known at compile time.</summary>
	</item>
	<item number="66" page="285">
		<title>Use native methods judiciously</title>
		<summary>Think twice before using native methods. It is rare that you need to use them for improved performance. If you must use native method to access low level resources or native libraries, use as little native code as possible and tested thoroughly. A single bug in the native code can corrupt your entire application.</summary>
	</item>
	<item number="67" page="286">
		<title>Optimize judiciously</title>
		<summary>Do not strive to write fast programs--strive to write good ones; speed will follow. But do you think about performance while you were designing systems, especially while you're designing APIs, wired-level protocols, and persistent formats. When you finished building the system, measure its performance. If it's fast enough, you're done. If not, locate the source of the problem with the aid of a profiler and go to work optimizing the relative parts of the system.</summary>
	</item>
	<item number="68" page="289">
		<title>Adhere to generally accepted naming conventions</title>
		<summary>Internalize the standard naming conventions and learn to use them as second nature. The typographical conventions are straightforward and largely unambiguous; the grammatical conventions or more complex and looser. To quote from *The Java Language Specification*, "These conventions should not be followed slavishly if long held conventional usage dictates otherwise". Use common sense.</summary>
	</item>
	<item number="69" page="293">
		<title>Use exceptions only for exceptional conditions</title>
		<summary>Exceptions are designed for exceptional conditions. Don't use them for ordinary control flow, and don't write APIs that force others to do so.</summary>
	</item>
	<item number="70" page="296">
		<title>Use checked exceptions for recoverable conditions and runtime exceptions for programming errors</title>
		<summary>Throw checked exceptions for recoverable conditions and unchecked exceptions for programming errors. When in doubt, throw unchecked exceptions. Don't define any throwables that are neither checked exceptions nor runtime exceptions. Provide methods on your checked exceptions to aid in recovery.</summary>
	</item>
	<item number="71" page="298">
		<title>Avoid unnecessary use of checked exceptions</title>
		<summary>When used sparingly, checked exceptions can increase the reliability of programs; when overused, they make APIs painful to use. If callers won't be able to recover from failures, throw unchecked exceptions. If recovery may be possible and you want to *force* callers to handle exceptional conditions, first consider returning an optional. Only if this would provide insufficient information in the case of failure should you throw a checked exception.</summary>
	</item>
	<item number="72" page="300">
		<title>Favor the use of standard exceptions</title>
		<summary>
			`IllegalArgumentException`: Non-null parameter value is inappropriate.
			`IllegalStateException`: Object state is inappropriate for method invocation.
			`NullPointerException`: Parameter value is null where prohibited.
			`IndexOutOfBoundsException`: Index parameter value is out of range.
			`ConcurrentModificationException`: Concurrent modification of an object has been detected where it is prohibited.
			`UnsupportedOperationException`: Object does not support method.
		</summary>
	</item>
	<item number="73" page="302">
		<title>Throw exceptions appropriate to the abstraction</title>
		<summary>If it isn't feasible to prevent or to handle exceptions from lower layers, use exception translation, unless the lower-level method happens to guarantee that all of its exceptions are appropriate to the higher level. Chaining provides the best of both worlds: it allows you to throw an appropriate higher level exception, while capturing the underlying cause for failure analysis (Item 75). </summary>
	</item>
	<item number="74" page="304">
		<title>Document all exceptions thrown by each method</title>
		<summary>Document every exception that can be thrown by each method that you write. This is true for unchecked as well as checked exceptions, and for abstract as well as concrete methods. This documentation should take the form of `@throws` tags in doc comments. Declare each checked exception individually in a method's `throws` clause, but do not declare unchecked exceptions. If you fail to document the exceptions that your methods can throw, it will be difficult or impossible for others to make effective use of your classes and interfaces.</summary>
	</item>
	<item number="75" page="306">
		<title>Include failure-capture information in detail messages</title>
		<summary>As suggested in Item 70, it may be appropriate for an exception to provide accessor methods for its failure capture information. It is more important to provide such accessor methods on checked exceptions than unchecked, because the failure-capture information could be useful in recovering from the failure. It is rare (although not inconceivable) that a programmer might want programmatic access to the details of an unchecked exception. Even for unchecked exceptions, however, it seems advisable to provide these accessors on general principle (Item 12, page 57).</summary>
	</item>
	<item number="76" page="308">
		<title>Strive for failure atomicity</title>
		<summary>As a rule, any generated exception that is part of a method's specification should leave the object in the same state it was prior to the method invocation. Where this rule is violated, the API documentation should clearly indicate what state the object will be left in. Unfortunately, plenty of existing API documentation fails to live up to this ideal.</summary>
	</item>
	<item number="77" page="310">
		<title>Don't ignore exceptions</title>
		<summary>The advice in this item applies equally to checked and unchecked exceptions. Whether an exception represents a predictable exceptional condition or a programming error, ignoring it with an empty `catch` block will result in a program that continues silently in the face of error. The program might then fail at an arbitrary time in the future, at a point in the code that bears no apparent relation to the source of the problem. Properly handling an exception can avert failure entirely. Merely letting an exception propagate outward can at least cause the program to fail swiftly, preserving information to aid in debugging the failure.</summary>
	</item>
	<item number="78" page="311">
		<title>Synchronize access to shared mutable data</title>
		<summary>When multiple threads share mutable data, each thread that reads or writes the data must perform synchronization. In the absence of synchronization, there is no guarantee that one thread's changes will be visible to another thread. The penalties for failing to synchronize shared mutable data are liveness and safety failures. These failures are among the most difficult to debug. They can be intermittent and timing-dependant, and program failure can vary radically from one VM to another. If you need only inter-thread communication, and not mutual exclusion, the `volatile` modifier is an acceptable form of synchronization, but it can be tricky to use correctly.</summary>
	</item>
	<item number="79" page="317">
		<title>Avoid excessive synchronization</title>
		<summary>To avoid deadlock and data corruption, never call an alien method from within a synchronized region. More generally, keep the amount of work that you do from within synkronized regions to a minimum. When you are designing a mutable class, think about whether it should do its own synchronization. In the multicore era, it is more important than ever not to oversynchronize. Synchronize your class internally only if there is a good reason to do so, and document your decision clearly (Item 82).</summary>
	</item>
	<item number="80" page="323">
		<title>Prefer executors, tasks, and streams to threads</title>
		<summary>You should generally refrain from working directly with threads. When you work directly with threads, a `Thread` serves as both a unit of work and the mechanism for executing it. In the executor framework, the unit of work and the execution mechanism are separate...If you think in terms of tasks and let and executor service execute them for you, you gain the flexibility to select an appropriate execution policy to meet your needs and to change the policy if your needs change. In essence, the Executor Framework does for execution what the Collections Framework did for aggregation.</summary>
	</item>
	<item number="81" page="325">
		<title>Prefer concurrency utilities to `wait` and `notify`</title>
		<summary>Using `wait` and `notify` directly is like programming in "concurrency assembly language," as compared to the higher level language provided by `java.util.concurrent`. There is seldom, if ever, a reason to use `wait` and `notify` in new code. If you maintain code that uses `wait` and `notify`, make sure that it always invokes `wait` from within a `while` loop using the standard idiom. The `notifyAll` method should generally be used in preference to `notify`. If `notify` is used, great care must be taken to ensure liveliness.</summary>
	</item>
	<item number="82" page="330">
		<title>Document thread safety</title>
		<summary>Every class should clearly document its thread safety properties with a carefully worded prose description or a thread safety annotation. The `synchronized` modifier plays no part in this documentation. Conditionally thread-safe classes must document which method invocation sequences require external synchronization in which lock to acquire when executing the sequences. If you write an unconditionally thread-safe class, consider using a private lock object in place of synchronized methods. This protects you against synchronization interference by clients and subclasses and gives you more flexibility to adopt a sophisticated approach to concurrency control in a later release.</summary>
	</item>
	<item number="83" page="333">
		<title>Use lazy initialization judiciously</title>
		<summary>You should initialize most fields normally, not lazily. If you must initialize a field lazily in order to achieve your performance goals or to break a harmful initialization circularity, then use the appropriate lazy initialization technique. For instance fields, it is the double-check idiom; for static fields, the lazy initialization holder class idiom. For instance fields that can tolerate repeated initialization, you may also consider the single-check idiom.</summary>
	</item>
	<item number="84" page="336">
		<title>Don't depend on the thread scheduler</title>
		<summary>Do not depend on the thread scheduler for the correctness of your program. The resulting program will be neither robust nor portable. As a corollary, do not rely on `Thread.yield` or thread priorities. These facilities are merely hints to the scheduler. Thread priorities may be used sparingly to improve the quality of service of an already working program, but they should never be used to "fix" a program that barely works.</summary>
	</item>
	<item number="85" page="339">
		<title>Prefer alternatives to Java serialization</title>
		<summary>Serialization is dangerous and should be avoided. If you are designing a system from scratch, use a cross-platform structured-data representation such as JSON or protobuf instead. Do not deserialize untrusted data. If you must do so, use object deserialization filtering, but be aware that it is not guaranteed to thwart all attacks. Avoid writing serializable classes. If you must do so, exercise great caution.</summary>
	</item>
	<item number="86" page="343">
		<title>Implement `Serializable` with great caution</title>
		<summary>The ease of implementing `Serializable` is specious. Unless a classe is to be used only in a protected environment where versions will never have to interoperate and servers will never be exposed to untrusted data, implementing `Serializable` is a serious commitment that should be made with great care. Extra caution is warranted if a class permits inheritance.</summary>
	</item>
	<item number="87" page="346">
		<title>Consider using a custom serialized form</title>
		<summary>If you have decided that a class should be serializable (Item 86), think hard about what the serialized form should be. Use the default serialized form *only* if it is a reasonable description of the logical state of the object; otherwise design a custom serialized form that aptly describe the object. You should allocate as much time to designing the serialized form of the class as you allocate to designing an exported method (Item 51). Just as you can't eliminate exported methods from future versions, you can't eliminate fields from the serialized form; they must be preserved forever to ensure serialization compatibility. Choosing the wrong serialized form can have a permanent, negative impact on the complexity and performance of a class.</summary>
	</item>
	<item number="88" page="353">
		<title>Write `readObject` methods defensively</title>
		<summary>Anytime you write a `readObject` method, adopt the mind-set that you are writing a public constructor that must produce a valid instance regardless of what byte stream it is given. Do not assume that the byte stream represents an actual serialized instance.</summary>
	</item>
	<item number="89" page="359">
		<title>For instance control, prefer enum types to `readResolve`</title>
		<summary>Use enum types to enforce instance control invariants wherever possible. If this is not possible and you need a class to be both serializable and instance-controlled, you must provide a `readResolve` method and ensure that all of the class's instance fields are either primitive or transient.</summary>
	</item>
	<item number="90" page="363">
		<title>Consider serialization proxies instead of serialized instances</title>
		<summary>Consider the serialization proxy pattern whenever you find yourself having to write a `readObject` or `writeObject` method on a class that is not extendable by its clients. This pattern is perhaps the easiest way to robustly serialize objects with nontrivial invariants.</summary>
	</item>
</items>
